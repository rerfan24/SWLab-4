# SWLab-4
Reza Erfan Arani - 98105919 - Software Lab #4 -  SOLID with TDD

## Code Explanation 
در این قسمت ما نخست با تعریف کردن کلاس `Rectangle` مستطیل خود را می سازیم و برای آن متدی تعریف میکنیم تا با set کردن طول و عرض بتواند با متد `area()` مساحت خود را حساب کند.
<br>
در اینجا تست ما برای داشتن یک `Rectangle` و حساب کردن مساحت آن و تایین طول عرض به خوبی کار می‌کند.
<br>
حال من یک کلاس به نام `Square` تعریف کردم که از `Rectangle` ارث می‌برد. مشکل این بود که اگر میخواست دقیقا مشخصات parent خود را داشته باشه میشد طول و عرض جدا بهش داد. حال اگر بگوییم که ما `if` می‌گذاریم تا در صورت set شدن هر کدام از مقادیر اون یکی هم ست کند شاید در این لحظه مشکل را برطرف کرده باشیم، اما طبق سناریوهای مختلف که برای توسعه نرم‌افزار پیش میاید باید چندین و چند `if` دیگر نیز بگذاریم.  و این ها باعث می‌شود که اصل LSP بهم بخورد. همچنین در صورتی که یکی از افراد دیگر نیز به این کد وابسته بوده باشد با هر کدام ازین `if`ها فهم قبلی اکتورهای مربوط دیگر نیز تغییر کرده و به آن‌ها نیز باید توضیح داده شود.
<br>
برای درست کردنش اولا من یک کلاس ابسترکت به اسم `Shape` درست کردم که هم `Rectangle` و هم `Square` از آن ارث بری میکنند که متد `area()` را باید پیاده سازی کنند.
<br>
بعد از این داخل کلاس `Square` یک متغییر به نام `side` تعریف شده است که همان تنها برای مربع باید set شود. اینگونه با abstrct کردن متد `area()` مشکلات برنامه قبلی رفع می‌شود و تست‌های ما بدون مشکل پاس می‌شوند.
<br>
## Answer to the Questions
### سوال اول
اصل اول: SRP: این اصل به معنای این است که هر کلاس باید تنها یک دلیل برای تغییر داشت هباشد یعنی اکتورهای متفاوتی از تغییر یک کلاس محبور به adapt شدن نشوند.
<br>
اصل دوم: OCP: کلاس‌ها باید جوری نوشته شوند که بعدها در تغییرات در اصل کد نوشته شده تغییری ایجاد نشود و تنها برای update کردن کد قبلی دست به تغییرات در کلاس بزنیم.
<br>
اصل سوم: LSP: هر child باید با parentش رابطه is A داشته باشد. یعنی یعنی هر متدی در child نباید pre-condition قوی تری داشته باشد و نباید post-conditionش قوی تر باشد. یعنی کارهایی که پدر میکند را باید بکند و نباید نپذیرد و مچپنین باید کارهای اضافه تری که لازم است child بکند را نیز انجام دهد. 
<br>
اصل چهارم: ISP: این اصل ی جورایی به ما میگوید که درست کردن چند interface بهتر ازین است که یک اینترفیس گنده همه کاره داشته باشیم. این یک جورایی مث <a href="https://en.wikipedia.org/wiki/God_object"> god class </a> درست کردن است و باعث می‌شود نتوانیم کلاس هایی را از اینترفیس‌هایی پیاده سازی کنیم و همه چیز را باید در همه کلاس‌ها با ایمپلیمنت کردن اینترفیس پیاده سازی کنیم.
<br>
اصل پنچم: DIP: منظور از این اصل این است که کلاس‌ها را بر اساس abstraction با هم تعامل کنند بهتر است. این خوب نیست که در یک کلاس به طور مستقیم از یک کلاس دیگر instance وجود داشته باشد و coupling بالا رود.  
### سوال دوم
این اصول بیشتر در گام تحلیل در ذهن باید شکل بگیرند. این اصول باید وقتی داریم کدمان را تحلیل میکنیم و ارتباط بین classها را در میاوریم در ذهن ما حواسمان بهش باشند و بعدا ما بتوانیم آن‌ها را در بخش طراحی روی کار بیاوریم. 
### سوال سوم
خیر تناقضی ندارد. نوشتن تست در ابتدای کار به برنامه‌نویس این امکان را می‌دهد که بر اساس تست‌های نوشته شده کد خود را بنویسد و این دید باز نسبت به نیاز‌های مسئله کمک می‌کند که کد‌نویسی نیز سریع‌تر و کم‌هزینه‌تر شود.
<br> 
در مدل سنتی اما تست‌ها بعد از develope کد نوشته می‌شد که این نیز روشی هست که ما از صحت کد خود با خبر می‌شویم  با اطمینان ان را تحویل می‌دهیم و این دو روش ابدا تناقضی با هم ندارند.
### سوال چهارم
اینگونه دیگر لازم نبود یک کلاس abstract تعریف کنیم (البته در این مسئله!!) و با همان ارث بری مربع از مستطیل کارمان انجام می‌شد. البته که بهتر است باز هم principleها را رعایت کنیم زیرا بعدا اگر بخواهیم چیزی به کد اضافه کنیم ممکن است دوباره این طراحی مشکل‌ساز شود.
